import { PrismaClient, JournalSentiment } from '@prisma/client';
import { logger } from '../utils/logger';

const prisma = new PrismaClient();

export class JournalAutoPopulationService {
  /**
   * Create a journal entry from a visit summary
   * Auto-generated entries are marked for easy identification
   */
  async createJournalFromVisit(params: {
    familyId: string;
    userId: string; // The user who uploaded the document
    documentId: string;
    visitSummary: string;
    visitDate: string | null | undefined;
    providerId: string | null;
    providerName?: string | null;
  }): Promise<string | null> {
    if (!params.visitSummary || params.visitSummary.trim().length === 0) {
      logger.debug('No visit summary provided, skipping journal entry creation');
      return null;
    }

    try {
      // Parse visit date or use current date
      const visitDate = params.visitDate
        ? this.parseDate(params.visitDate)
        : new Date();

      // Analyze sentiment from the summary text
      const sentiment = this.analyzeSentiment(params.visitSummary);

      // Format the journal content
      const providerInfo = params.providerName
        ? ` with ${params.providerName}`
        : params.providerId
        ? ' with healthcare provider'
        : '';

      const content = `Visit${providerInfo} on ${this.formatDate(visitDate)}

${params.visitSummary}

---
Auto-generated from uploaded medical document.`;

      // Create the journal entry
      const journalEntry = await prisma.journalEntry.create({
        data: {
          familyId: params.familyId,
          userId: params.userId,
          content,
          sentiment,
          isPrivate: false, // Medical visit summaries are not private by default
          sourceDocumentId: params.documentId,
          visitDate,
          providerId: params.providerId,
          autoGenerated: true,
          createdAt: visitDate, // Use visit date as creation date for chronological sorting
        },
      });

      logger.info(
        `Created auto-generated journal entry ${journalEntry.id} for visit on ${this.formatDate(visitDate)}`
      );
      return journalEntry.id;
    } catch (error) {
      logger.error('Error creating journal entry from visit:', error);
      return null;
    }
  }

  /**
   * Analyze sentiment from visit summary text
   * Simple keyword-based approach - could be enhanced with AI
   */
  private analyzeSentiment(text: string): JournalSentiment {
    const lower = text.toLowerCase();

    // Check for urgent/concerning keywords
    const urgentKeywords = [
      'emergency',
      'urgent',
      'critical',
      'severe',
      'immediate',
      'hospital',
      'admitted',
      'er',
    ];
    if (urgentKeywords.some((keyword) => lower.includes(keyword))) {
      return 'urgent';
    }

    // Check for concerning keywords
    const concernedKeywords = [
      'concerned',
      'worried',
      'deteriorat',
      'declined',
      'worse',
      'pain',
      'difficulty',
      'struggling',
      'confused',
      'problem',
    ];
    if (concernedKeywords.some((keyword) => lower.includes(keyword))) {
      return 'concerned';
    }

    // Check for positive keywords
    const positiveKeywords = [
      'improved',
      'better',
      'stable',
      'good',
      'well',
      'progress',
      'recovering',
      'successful',
    ];
    if (positiveKeywords.some((keyword) => lower.includes(keyword))) {
      return 'positive';
    }

    // Default to neutral
    return 'neutral';
  }

  /**
   * Parse date string to Date object
   * Handles common date formats
   */
  private parseDate(dateString: string): Date {
    // Try ISO format first (YYYY-MM-DD)
    if (/^\d{4}-\d{2}-\d{2}/.test(dateString)) {
      return new Date(dateString);
    }

    // Try MM/DD/YYYY
    if (/^\d{1,2}\/\d{1,2}\/\d{4}/.test(dateString)) {
      return new Date(dateString);
    }

    // Try parsing as-is
    const parsed = new Date(dateString);
    if (!isNaN(parsed.getTime())) {
      return parsed;
    }

    // Fallback to current date
    logger.warn(`Could not parse date: ${dateString}, using current date`);
    return new Date();
  }

  /**
   * Format date for display in journal entry
   */
  private formatDate(date: Date): string {
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  }
}

export const journalAutoPopulationService = new JournalAutoPopulationService();
